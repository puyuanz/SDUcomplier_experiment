该过程与语法分析和语法制导翻译与中间代码两章理论完全重合，难点在于如何将手写的过程用程序自动化实现。过程如下：
1. 预处理和词法分析与上个题目相同，形成token流
2. 构造LR(1)语法分析器(Parser()函数)
   1. 将翻译文法写到grammar变量中，包含每个产生左侧的非终结符、右侧的符号以及末尾的语义规则。
   2. 获取first集合(用于LR(1)项目中要扩展项时选择搜索符号)，follow集合没有用但是也实现了，具体算法见[理论4.1.2节内容](http://github/)。
   3. 构造LR(1)项目集规范族，具体算法见[理论4.2节内容]()
      1. 初始化$I^{(0)}=Closure(S'\rightarrow S)$
      2. 对前面可移进的项目进行移进，例如$I^{(j)}=Go(I^{(i)},\alpha)$，Go函数实现如下：
         - 对可移进$\alpha$的项进行移进，同时保留搜索符号lookAhead
         - 移进后获取该项的Clousure加入到里面。获取Clousure的实现如下：
           - 获取该项小数点后的第一个符号
           - 如果是终结符直接return
           - 如果是非终结符，搜索所有该以该非终结符号作为的左端的产生式将它进行扩展。对每一个扩展的项目：
             - 如果这个非终结符后面没有任何符号，则直接用上一个项的选择符号作为选择符号
             - 如果非终结符后面有符号，获取后面符号的first，作为该项的选择符号
           - 整个过程递归实现，用到队列queue
      3. 判断移进之后获得的$I^{(j)}$是否为新的项目：
         - 新的，直接插入到StateTransSet和C中
         - 旧的已经存在，则合并选择符号(这里还是不太理解)
    4. 实现LR1分析程序
       - Action[i,a]=sk时候把输入串栈顶元素压入符号栈，同时弹出输入串。然后状态栈压入k
       - Goto[i,A]=j的时候，就把状态栈压入j
       - Action[i,a]=rk，通过看是否有出边判断，没出便说明要归约，要执行最后的语义规则函数
3. 分析程序(run()函数)
   - LR1分析程序构造好了，直接看符号栈头是什么元素，直接对应找表对应的分析程序就好，执行这些程序就可以得到中间代码
4. 最后按照题目要求输出相应信息即可。