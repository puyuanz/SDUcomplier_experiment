## 1 对源程序进行数据预处理
采用和词法分析类似的状态机算法。从头到尾遍历。遍历到第i个字符的状态有三种：
- 0：在`/**/`的注释块中
- 1：在`//`的注释行中
- 2：在非注释区域

这么排序的目的也在于考虑到在注释块中出现注释行的情况，优先进入状态0。

不同状态的转换关系：
- 在状态0匹配到'*/'后转为状态2
- 在状态1匹配到'\n'后转为状态2
- 状态2匹配到'/*'后转为状态0；状态2匹配到'//'后转为状态1

不同状态的预处理操作：
- 状态0和状态1：直接i++，忽略注释内容
- 状态2：
  - 如果字符是'\n'或'\t'或'\r'或空格，将'\n'、'\t'和'\r'替换成空格，同时看前一个字符是否为空格，
    - 如果前一个字符也是空格，就直接i++跳过这个空格
    - 不是空格则将这第一个空格加入到预处理字符串中
  - 字符不是'\n'或'\t'或'\r'或空格则直接加入预处理字符串。

## 2 词法分析
分为三个状态：
- 0(INIT)：用来匹配'>'、'<'、'='、'!'、'=='、'>='、'<='、'!='、'&&'、'||'、'{'、'}'、';'、'('、')'、','、'+'、'-'、'*'、'/'这些比较、运算、分界、赋值符号。
- 1(WORD)：用来匹配特殊符号(int、while等)和变量标识符
- 2(NUM)：用来匹配数字常量，包括小数
- 3(FINAL)：结束态，最长匹配到一个token之后或者遇到空格。具体代码实现没有用state表示，而是通过break来实现。

状态转化：
- 状态0(INIT)：
  - 当前字符为字母：转为状态1(WORD)
  - 当前字符为数字，转为状态2(NUM)
  - 当前字符非数字和字母：
    - 如果是'>'、'<'、'='、'!'的一种将它加入到新的token字符串中，看下一个字符是否有'='，是'='就也加入到token中，然后转为状态3(FINAL)。这里包含了对所有比较符号、赋值符号以及取反符号的词法分析。
    - 如果是'&'、'|'，加入到token中，看是否是双符号'&&'、'||'，是则一并加入到token中，然后转为状态3(FINAL)。这里包含了对位运算和条件运算的符号的词法分析
    - 如果是'{'、'}'、';'、'('、')'、','、'+'、'-'、'*'、'/'，则直接作为单符号token写到token中，然后转为状态3(FINAL)
- 状态1(WORD)
  - 当前字符是字母，则仍然跳转到当前状态
  - 不是字母，就跳转到状态3(FINAL)
- 状态2(NUM)
  - 当前字符是数字或小数点，则仍然跳转到当前状态
  - 不是字母，就跳转到状态3(FINAL)
- 状态3(FINAL)：对产生的token匹配(通过map)对应的标志信息，然后写到数对中，同时添加对小数的错误信息检查，然后跳转到状态0(INIT)。

## 3 感悟
如果按照理论学习的时候的词法分析DFA的那个步骤，对特殊符号、单符号比较符号、双符号比较符号等等都设置很多个状态去匹配的话，状态数量会非常庞大，同时字符种类也很多，因此那个状态表(每个状态对应的每一种字符跳转到的状态数的表格)就会很大，占用空间很大。且这个二维表是很稀疏的，因为每个状态可能就有几个符号有出边。不利于提升空间利用率(当然也可以用一些压缩算法表示稀疏矩阵，但是问题会很复杂)。

因此这里自动状态机的实现是减少状态数量，即用NFA，通过switch跳转不同的状态，执行相应条件语句来实现不同情况的跳转和处理，以实现某个状态检测特定某几类符号的效果。
